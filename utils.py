import sys
import numpy as np
import datetime
from dateutil.tz import tzutc
from dateutil.parser import parse as parsedate

PY2 = sys.version_info < (3, 0)


def str2date(string, fmt=None):
    if fmt is None:
        date_object = parsedate(string)
    else:
        date_object = datetime.datetime.strptime(string, fmt)
    if date_object.tzinfo is None:
        date_object = date_object.replace(tzinfo=tzutc())
    return date_object


# @profile
# def blockgen(array, bpa):
#     """
#     https://stackoverflow.com/a/16865342
#
#     Creates a generator that yields multidimensional blocks from the given
#     array(_like); bpa is an array_like consisting of the number of blocks
#     per axis (minimum of 1, must be a divisor of the corresponding axis size
#     of array). As the blocks are selected using normal numpy slicing, they
#     will be views rather than copies; this is good for very large
#     multidimensional arrays that are being blocked, and for very large
#     blocks, but it also means that the result must be copied if it is to be
#     modified (unless modifying the original data as well is intended).
#     """
#     bpa = np.asarray(bpa) # in case bpa wasn't already an ndarray
#
#     # parameter checking
#     if array.ndim != bpa.size:
#         # bpa doesn't match array dimensionality
#         raise ValueError("Size of bpa must be equal to the array "
#                          "dimensionality.")
#     if (bpa.dtype != np.int            # bpa must be all integers
#         or (bpa < 1).any()             # all values in bpa must be >= 1
#         or (array.shape % bpa).any()): # % != 0 means not evenly divisible
#         raise ValueError("bpa ({0}) must consist of nonzero positive "
#                          "integers that evenly divide the corresponding "
#                          "array axis size".format(bpa))
#
#     # generate block edge indices
#     rgen = (np.r_[:array.shape[i]+1:array.shape[i]//blk_n]
#             for i, blk_n in enumerate(bpa))
#
#     # build slice sequences for each axis (unfortunately broadcasting
#     # can't be used to make the items easy to operate over
#     c = [[np.s_[i:j] for i, j in zip(r[:-1], r[1:])] for r in rgen]
#
#     # Now to get the blocks; this is slightly less efficient than it could be
#     # because numpy doesn't like jagged arrays and I didn't feel like writing
#     # a ufunc for it.
#     for idxs in np.ndindex(*bpa):
#         blockbounds = tuple(c[j][idxs[j]] for j in range(bpa.size))
#         yield array[blockbounds]


def chunks(l, n):
    """Yield successive n-sized chunks from l.

    https://stackoverflow.com/a/312464

    Parameters
    ----------
    l : iterable
        The list or list-like object to be split into chunks.
    n : int
        The size of the chunks to be generated.

    Yields
    ------
    iterable
        Consecutive slices of l of size n.
    """
    range_fn = range if not PY2 else xrange
    for i in range_fn(0, len(l), n):
        yield l[i:i + n]


def array_chunks(array, n, axis=0, return_indices=False):
    """Chunk an array along the given axis.

    Parameters
    ----------
    array : numpy.array
        The array to be chunked
    n : int
        The chunksize.
    axis : int, optional
        The axis along which to split the array into chunks (default: 0).
    return_indices : bool, optional
        If True, yield the array index that will return chunk rather
        than the chunk itself (default: False).

    Yields
    ------
    iterable
        Consecutive slices of `array` of size `n`.
    """
    if axis >= array.ndim:
        raise ValueError("axis {:d} is out of range for given array."
                         .format(axis))

    arr_len = array.shape[axis]
    range_fn = range if not PY2 else xrange
    for i in range_fn(0, arr_len, n):
        indices = [slice(None), ] * array.ndim
        indices[axis] = slice(i, i+n)
        if return_indices:
            yield indices, array[indices]
        else:
            yield array[indices]


# def blockmerge(array, bpa):
#     """
#     Reassemble a list of arrays as generated by blockgen.
#     """
#     if len(array) != np.prod(bpa):
#         raise ValueError("Length of array must be equal to the product of "
#                          "the shape elements.")
#     # if array.ndim != len(bpa):
#     #     raise ValueError("Size of bpa must be equal to the array "
#     #                      "dimensionality.")
#
#     result = array
#     for i, l in enumerate(bpa[::-1]):
#         result = np.concatenate([_ for _ in chunks(result, l)],
#                                 axis=len(bpa)-i-1)
#         # return np.concatenate([np.concatenate(_, axis=1) for _ in
#         #                        chunks(array, bpa[1])], axis=0)
#     return result


def block_split(array, blocks):
    """Split an ndarray into subarrays according to blocks.

    Parameters
    ----------
    array : numpy.ndarray
        The array to be split.
    blocks : array_like
        The desired number of blocks per axis.

    Returns
    -------
    list
        A list of blocks, in column-major order.

    Examples
    --------
    >>> block_split(np.arange(16).reshape((4,4)))
    [array([[ 0,  1],
            [ 4,  5]]),
     array([[ 2,  3],
            [ 6,  7]]),
     array([[ 8,  9],
            [12, 13]]),
     array([[10, 11],
            [14, 15]])]
    """
    if array.ndim != len(blocks):
        raise ValueError("Length of 'blocks' must be equal to the "
                         "array dimensionality.")

    result = [array]
    for axis, nblocks in enumerate(blocks):
        result = [np.array_split(_, nblocks, axis=axis) for _ in result]
        result = [item for sublist in result for item in sublist]
    return result


def block_merge(array_list, blocks):
    """Reassemble a list of arrays as generated by block_split.

    Parameters
    ----------
    array_list : list of numpy.array
        A list of numpy.array, e.g. as generated by block_split().
    blocks : array_like
        The number of blocks per axis to be merged.

    Returns
    -------
    numpy.array
        A numpy array with dimension len(blocks).
    """
    if len(array_list) != np.prod(blocks):
        raise ValueError("Length of array list must be equal to the "
                         "product of the shape elements.")

    result = array_list
    for i, nblocks in enumerate(blocks[::-1]):
        axis = len(blocks) - i - 1
        result = [np.concatenate(_, axis=axis)
                  for _ in chunks(result, nblocks)]
    return result[0]
